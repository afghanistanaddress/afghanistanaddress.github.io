<!DOCTYPE html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://afghanistanaddress.github.io/html/category/article-1695.htm" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>nodejs的TCP相关的一些笔记 - Afghanistan Address</title>
        <link rel="icon" href="/assets/addons/xcblog/img/afghanistanaddress/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="/assets/addons/xcblog/js/frontend/afghanistanaddress/animate/animate.css">
    <link rel="stylesheet" href="/assets/addons/xcblog/css/afghanistanaddress/bootstrap.css">
    <link rel="stylesheet" href="/assets/addons/xcblog/css/afghanistanaddress/maicons.css">
    <link rel="stylesheet" href="/assets/addons/xcblog/js/frontend/afghanistanaddress/owl-carousel/css/owl.carousel.css">
    <link rel="stylesheet" href="/assets/addons/xcblog/css/afghanistanaddress/theme.css">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?07d6804a416dbd216ab0e3d3e283ddad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
    <!-- Back to top button -->
    <div class="back-to-top"></div>
    <header>
                <nav class="navbar navbar-expand-lg navbar-light navbar-float">
            <div class="container">
                                <a href="/" class="navbar-brand">Afghanistan Address</a>
                                <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="navbar-collapse collapse" id="navbarContent">
                    <ul class="navbar-nav ml-lg-4 pt-3 pt-lg-0">
                                                <li class="nav-item">
                            <a href="/" class="nav-link">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a href="/html/category/" class="nav-link">文章分类</a>
                        </li>
                                                <li class="nav-item">
                            <a href="#" class="nav-link">关于</a>
                        </li>
                        <li class="nav-item">
                            <a href="#" class="nav-link">联系</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container mt-5">
            <div class="page-banner">
                <div class="row justify-content-center align-items-center h-100">
                    <div class="col-md-10">
                        <h1 class="text-center">nodejs的TCP相关的一些笔记</h1>
                        <nav aria-label="Breadcrumb">
                            <ul class="breadcrumb justify-content-center py-0 bg-transparent">
                                <li class="breadcrumb-item"><a href="/">首页</a></li>
                                <li class="breadcrumb-item"><a href="/html/category/">文章分类</a></li>
                                <li class="breadcrumb-item active">正文</li>
                            </ul>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <main>
        <div class="page-section">
            <div class="container">
                <div class="row">
                    <div class="col-md-9">
                          				  				  				<ul style="color: rgba(236, 83, 21, 1)"> <li>TCP协议</li> <li>基于nodejs创建TCP服务端</li> <li>TCP服务的事件</li> <li>TCP报文解析与粘包解决方案</li> </ul> <h2 style="background-color: rgba(236, 83, 21, 1); border-radius: 5px; color: rgba(255, 255, 255, 1)">&nbsp;一、TCP协议</h2> <p>1.1TCP协议原理部分参考：<a style="color: rgba(0, 0, 255, 1)" href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/ZheOneAndOnly/p/10582436.html"  target="_blank" rel="nofollow"> 无连接运输的UDP、可靠数据传输原理、面向连接运输的TCP</a></p> <p>1.2图解七层协议、TCP三次握手、TCP四次挥手：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/f0392ee0e60c2b949ea9a6ce60d6cc35.jpg" alt="nodejs的TCP相关的一些笔记"></p> <h2 style="background-color: rgba(236, 83, 21, 1); border-radius: 5px; color: rgba(255, 255, 255, 1)">&nbsp;二、基于nodejs创建TCP服务端</h2> <p>&nbsp;2.1<strong>创建nodejs的TCP服务实例</strong>(server.js)：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> const net = require('net'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 2</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建服务实例</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> const server =<span style="color: rgba(0, 0, 0, 1)"> net.createServer();</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> const PORT = 12306<span style="color: rgba(0, 0, 0, 1)">;</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> const HOST = 'localhost'<span style="color: rgba(0, 0, 0, 1)">;</span><span style="color: rgba(0, 128, 128, 1)"> 6</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">服务启动对网络资源的监听</span><span style="color: rgba(0, 128, 128, 1)"> 7</span><span style="color: rgba(0, 0, 0, 1)">server.listen(PORT, HOST);</span><span style="color: rgba(0, 128, 128, 1)"> 8</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当服务启动时触发的事件</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> server.on('listening', ()=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">    console.log(`服务已开启在 ${HOST}: ${PORT}`);</span><span style="color: rgba(0, 128, 128, 1)">11</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">12</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">接收消息，响应消息</span><span style="color: rgba(0, 128, 128, 1)">13</span> server.on('connection', (socker) =&gt;<span style="color: rgba(0, 0, 0, 1)"> {</span><span style="color: rgba(0, 128, 128, 1)">14</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">通过Socket上的data事件接收消息</span><span style="color: rgba(0, 128, 128, 1)">15</span>     socker.on('data', (chunk) =&gt; {<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">通过Socket上的writer方法回写响应数据</span><span style="color: rgba(0, 128, 128, 1)">16</span>         const msg =<span style="color: rgba(0, 0, 0, 1)"> chunk.toString();</span><span style="color: rgba(0, 128, 128, 1)">17</span><span style="color: rgba(0, 0, 0, 1)">        console.log(msg);</span><span style="color: rgba(0, 128, 128, 1)">18</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">通过Socket上的writer方法回写响应数据</span><span style="color: rgba(0, 128, 128, 1)">19</span>         socker.write('您好' +<span style="color: rgba(0, 0, 0, 1)"> msg);</span><span style="color: rgba(0, 128, 128, 1)">20</span><span style="color: rgba(0, 0, 0, 1)">    });</span><span style="color: rgba(0, 128, 128, 1)">21</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">22</span> server.on('close', ()=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">23</span>     console.log('服务端关闭了'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)">24</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">25</span> server.on('error', (err) =&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">26</span><span style="color: rgba(0, 0, 255, 1)">if</span>(err.code === 'EADDRINUSE'<span style="color: rgba(0, 0, 0, 1)">){</span><span style="color: rgba(0, 128, 128, 1)">27</span>         console.log('地址正在被使用'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)">28</span>     }<span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">29</span><span style="color: rgba(0, 0, 0, 1)">        console.log(err);</span><span style="color: rgba(0, 128, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">31</span> });</pre> </div> <p>2.2<strong>创建nodejs的TCP客户端实例</strong>(client.js)：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> const net = require('net'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 2</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建客户实例,并与服务端建立连接</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> const client =<span style="color: rgba(0, 0, 0, 1)"> net.createConnection({</span><span style="color: rgba(0, 128, 128, 1)"> 4</span>     port:12306<span style="color: rgba(0, 0, 0, 1)">,</span><span style="color: rgba(0, 128, 128, 1)"> 5</span>     host:'127.0.0.1'<span style="color: rgba(0, 128, 128, 1)"> 6</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)"> 7</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当套字节与服务端连接成功时触发connect事件</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> client.on('connect', () =&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     client.write('他乡踏雪');<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">向服务端发送数据</span><span style="color: rgba(0, 128, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">11</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">使用data事件监听服务端响应过来的数据</span><span style="color: rgba(0, 128, 128, 1)">12</span> client.on('data', (chunk) =&gt;<span style="color: rgba(0, 0, 0, 1)"> {</span><span style="color: rgba(0, 128, 128, 1)">13</span><span style="color: rgba(0, 0, 0, 1)">    console.log(chunk.toString());</span><span style="color: rgba(0, 128, 128, 1)">14</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">15</span> client.on('error', (err)=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">16</span><span style="color: rgba(0, 0, 0, 1)">    console.log(err);</span><span style="color: rgba(0, 128, 128, 1)">17</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">18</span> client.on('close', ()=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">19</span>     console.log('客户端断开连接'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)">20</span> });</pre> </div> <p>然后使用nodemon工具启动服务(如果没有安装nodemon工具可以使用npm以管理员身份安装)，当然也可以直接使用node指令启动，使用nodemon的好处就是当你修改代码保存后它会监听文件的变化自动重启服务：</p> <div style="background-color: rgba(43, 43, 43, 1); color: rgba(255, 255, 255, 1); padding: 5px"> <p>nodemon .\server.js</p> <p>[nodemon] 2.0.15<br />[nodemon] to restart at any time, enter `rs`<br />[nodemon] watching path(s): *.*<br />[nodemon] watching extensions: js,mjs,json<br />[nodemon] starting `node .\server.js`<br />服务已开启在 localhost: 12306</p> </div> <p>然后接着使用nodemon工具启动客户端程序，创建客户端实例连接服务器并发送TCP消息：</p> <div style="background-color: rgba(43, 43, 43, 1); color: rgba(255, 255, 255, 1); padding: 5px"> <p>nodemon .\client.js</p> <p>[nodemon] 2.0.15<br />[nodemon] to restart at any time, enter `rs`<br />[nodemon] watching path(s): *.*<br />[nodemon] watching extensions: js,mjs,json<br />[nodemon] starting `node .\client.js`<br />您好他乡踏雪</p> </div> <p>服务端接收到消息以后并在消息前添加“您好”后返回该消息，服务端的控制台会先打印一下内容：</p> <div style="background-color: rgba(43, 43, 43, 1); color: rgba(255, 255, 255, 1); padding: 5px"> <p>他乡踏雪</p> </div> <p>以上就是一个简单的TCP服务与客户端的交互示例，除了使用nodemon启动服务和客户端以外，还可以使用系统的telnet工具在控制台上测试连接服务，你的系统可能默认没有启动这个程序，telnet相关使用可以参考这里：<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://baijiahao.baidu.com/s?id=1723367561977342393&amp;wfr=spider&amp;for=pc"  rel="nofollow">https://baijiahao.baidu.com/s?id=1723367561977342393&amp;wfr=spider&amp;for=pc</a></p> <p>2.3<strong>TCP服务的事件</strong>：</p> <p>在前面的示例代码中已经有了TCP事件相关API的应用代码，这里针对这些事件做一些概念性的介绍：</p> <p>通过net.createServer()创建的服务，它是一个EventEmitter实例，这个示例负责启动nodejs底层TCP模块对网络资源的监听。在这个实例内部还会管理一个Socket实例，它是一个双工流(<a style="color: rgba(0, 0, 255, 1)" href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/ZheOneAndOnly/p/15946917.html"  target="_blank" rel="nofollow">关于双工流点击参考</a>)实例，Socket实例负责接收和响应具体的TCP数据。</p> <p>net.createServer()上的事件：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 0, 0, 1)">listening:调用server.listen()绑定端口或者Domain Socket后触发。 connection:每个客户端套字节连接到服务器时触发，其回调函数会接收到一个Socket实例作为参数。 close:当服务器关闭时触发，在调用server.close()后，服务器将停止接收新的套字节连接，但保持当前存在的连接，等待所有连接断开后，会触发该事件。 error:当服务器发生异常时，将会触发该事件。</span></pre> </div> <p>连接事件，也就是Socket实例上的事件，这个事件对应tream实例上的事件，因为Socket本身就是基于双工流构造的。</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 0, 0, 1)">data:当一端调用write()方法发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。 end:当连接中的任意一段发送了FIN数据时，将会触发该事件。 connect:该事件用于客户端，当套字节与服务器连接成功后会触发。 drain:当任意一端调用write()发送数据时，当前端会触发该事件。 error:当异常发生时，触发该事件。 close:当套字节完全关闭时，触发该事件。 timeout:当一定事件后连接不在活跃时，该事件将会触发，通知用户当前连接已经被闲置。</span></pre> </div> <h2 style="background-color: rgba(236, 83, 21, 1); border-radius: 5px; color: rgba(255, 255, 255, 1)">&nbsp;三、TCP报文解析与粘包解决方案</h2> <p>由于TCP针对网络中小数据包有一定的优化策略：Nagle算法。</p> <p>如果每次发送一个很小的数据包，比如一个字节内容的数据包而不优化，就会导致网络中只有极少数有效数据的数据包，这会导致浪费大量的网络资源。Nagle算法针对这种情况，要求缓存区的数据达到一定数据量或者一定时间后才将其发出，所以数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然提高了网络带宽的效率，但有的数据可能会被延迟发送。</p> <p>在Nodejs中，由于TCP默认启动Nagle算法，可以调用socket.setNoDelay(ture)去掉Nagle算法，使得write()可以立即发送数据到网络中。但需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不是每次write()都会触发另一端的data事件，再关闭Nagle算法后，接收端可能会将接收到的多个小数据包合并，然后只触发一次data事件。也就是说socket.setNoDelay(ture)只能解决一端的数据粘包问题。</p> <p>使用第二节中的client.js示例代码来测试数据粘包问题：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">在客户端的connect事件回调中通过多个write()发送数据，它可能会将多次write()写入的数据一次发出</span> client.on('connect', () =&gt;<span style="color: rgba(0, 0, 0, 1)">{     client.write(</span>'他乡踏雪');<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">向服务端发送数据</span>     client.write('他乡踏雪1'<span style="color: rgba(0, 0, 0, 1)">);     client.write(</span>'他乡踏雪2'<span style="color: rgba(0, 0, 0, 1)">);     client.write(</span>'他乡踏雪3'<span style="color: rgba(0, 0, 0, 1)">); });</span></pre> </div> <p>我的测试结果是在服务端和客户端都出现了粘包问题：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/5dec61c3376818739d0b124830d0dfd1.jpg" alt="nodejs的TCP相关的一些笔记"></p> <p>3.1<strong>解决粘包问题的简单粗暴的方案</strong>：</p> <p>将多次write()发送的数据，通过定时器延时发送，这个延时超过Nagle算法优化合并的时间就可以解决粘包的问题。比如上面的示例代码可以修改成下面这样：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> let dataArr = ["他乡踏雪","他乡踏雪","他乡踏雪"<span style="color: rgba(0, 0, 0, 1)">];</span><span style="color: rgba(0, 128, 128, 1)"> 2</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当套字节与服务端连接成功时触发connect事件</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> client.on('connect', () =&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)"> 4</span>     client.write('他乡踏雪');<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">向服务端发送数据</span><span style="color: rgba(0, 128, 128, 1)"> 5</span><span style="color: rgba(0, 0, 255, 1)">for</span>(let i = 0; i&lt; dataArr.length; i++<span style="color: rgba(0, 0, 0, 1)">){</span><span style="color: rgba(0, 128, 128, 1)"> 6</span>         (<span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(data, index){</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>             setTimeout(()=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)"> 8</span><span style="color: rgba(0, 0, 0, 1)">                client.write(data);</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>             },1000 *<span style="color: rgba(0, 0, 0, 1)"> i);</span><span style="color: rgba(0, 128, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">        })(dataArr[i], i);</span><span style="color: rgba(0, 128, 128, 1)">11</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">12</span> });</pre> </div> <p>上面这种方案会导致网络连接的资源长时间被占用，用户体验上也会大打折扣，这显然不是一个合理的方案。</p> <p>3.2<strong>通过拆包封包的方式解决数据粘包的问题分析</strong>：</p> <p>通过前面的示例和对TCP数据传输机制双工流的可以了解，TCP粘包的问题就是数据的可写流因为Nagle算法的优化，不会按照发送端的write()的写入对应触发接收端的data事件，它可能导致数据传输出现以下两种情况：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 0, 0, 1)">发送端多次write()的数据可能被打包成一个数据包发送到接收端。 发送端通过write()一次写入的数据可能因为Nagle算法的优化被截断到两个数据包中。</span></pre> </div> <p>TCP的数据传输虽然可能会出现以上两种问题，但由于它是基于流的传输机制，那么它的数据顺序在传输过程中是确定的先进先出原则。所以，可以通过在每次write()在数据头部添加一些标识，将每次write()传输的数据间隔开，然后在接收端基于这些间隔数据的标识将数据拆分或合并。</p> <p>基于定长的消息头头和不定长的消息体，封包拆包实现数据在流中的标识：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 0, 0, 1)">消息头：也就是间隔数据的标识，采用定长的方式就可以实现有规律的获取这些数据标识。消息头中包括消息系列号、消息长度。 消息体：要传输的数据本身。</span></pre> </div> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/ad26bee79b455e67d2d8b1477cf57275.jpg" alt="nodejs的TCP相关的一些笔记"></p> <p>封包与拆包的工具模块具体实现(MyTransform.js)：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span><span style="color: rgba(0, 0, 0, 1)">class MyTransformCode{</span><span style="color: rgba(0, 128, 128, 1)"> 2</span><span style="color: rgba(0, 0, 0, 1)">    constructor(){</span><span style="color: rgba(0, 128, 128, 1)"> 3</span><span style="color: rgba(0, 0, 255, 1)">this</span>.packageHeaderLen = 4;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">设置定长的消息头字节长度</span><span style="color: rgba(0, 128, 128, 1)"> 4</span><span style="color: rgba(0, 0, 255, 1)">this</span>.serialNum = 0;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息序列号</span><span style="color: rgba(0, 128, 128, 1)"> 5</span><span style="color: rgba(0, 0, 255, 1)">this</span>.serialLen = 2;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头中每个数据占用的字节长度（序列号、消息长度值）</span><span style="color: rgba(0, 128, 128, 1)"> 6</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)"> 7</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">编码</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     encode(data, serialNum){<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">data:当前write()实际要传输的数据； serialNum:当前消息的编号</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>         const body = Buffer.from(data);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将要传输的数据转换成二进制</span><span style="color: rgba(0, 128, 128, 1)">10</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">01 先按照指定的长度来申请一片内存空间作为消息头header来使用</span><span style="color: rgba(0, 128, 128, 1)">11</span>         const headerBuf = Buffer.alloc(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.packageHeaderLen);</span><span style="color: rgba(0, 128, 128, 1)">12</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">02写入包的头部数据</span><span style="color: rgba(0, 128, 128, 1)">13</span>         headerBuf.writeInt16BE(serialNum ||<span style="color: rgba(0, 0, 255, 1)">this</span>.serialNum);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将当前消息编号以16进制写入</span><span style="color: rgba(0, 128, 128, 1)">14</span>         headerBuf.writeInt16BE(body.length,<span style="color: rgba(0, 0, 255, 1)">this</span>.serialLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将当前write()写入的数据的二进制长度作为消息的长度写入</span><span style="color: rgba(0, 128, 128, 1)">15</span><span style="color: rgba(0, 0, 255, 1)">if</span>(serialNum ===<span style="color: rgba(0, 0, 0, 1)"> undefined){</span><span style="color: rgba(0, 128, 128, 1)">16</span><span style="color: rgba(0, 0, 255, 1)">this</span>.serialNum ++;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果没有传入指定的序列号，表示在最佳写入，消息序列号+1</span><span style="color: rgba(0, 128, 128, 1)">17</span><span style="color: rgba(0, 0, 0, 1)">        }</span><span style="color: rgba(0, 128, 128, 1)">18</span><span style="color: rgba(0, 0, 255, 1)">return</span> Buffer.concat([headerBuf, body]);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将消息头和消息体合并成一个Buffer返回，交给TCP发送端</span><span style="color: rgba(0, 128, 128, 1)">19</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">20</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解码</span><span style="color: rgba(0, 128, 128, 1)">21</span><span style="color: rgba(0, 0, 0, 1)">    decode(buffer){</span><span style="color: rgba(0, 128, 128, 1)">22</span>         const headerBuf = buffer.slice(0,<span style="color: rgba(0, 0, 255, 1)">this</span>.packageHeaderLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取消息头的二进制数据</span><span style="color: rgba(0, 128, 128, 1)">23</span>         const bodyBuf = buffer.slice(<span style="color: rgba(0, 0, 255, 1)">this</span>.packageHeaderLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取消息体的二进制数据</span><span style="color: rgba(0, 128, 128, 1)">24</span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {</span><span style="color: rgba(0, 128, 128, 1)">25</span><span style="color: rgba(0, 0, 0, 1)">            serialNum:headerBuf.readInt16BE(),</span><span style="color: rgba(0, 128, 128, 1)">26</span>             bodyLength:headerBuf.readInt16BE(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.serialLen),</span><span style="color: rgba(0, 128, 128, 1)">27</span><span style="color: rgba(0, 0, 0, 1)">            body:bodyBuf.toString()</span><span style="color: rgba(0, 128, 128, 1)">28</span><span style="color: rgba(0, 0, 0, 1)">        };</span><span style="color: rgba(0, 128, 128, 1)">29</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">30</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取数据包长度的方法</span><span style="color: rgba(0, 128, 128, 1)">31</span><span style="color: rgba(0, 0, 0, 1)">    getPackageLen(buffer){</span><span style="color: rgba(0, 128, 128, 1)">32</span><span style="color: rgba(0, 0, 255, 1)">if</span>(buffer.length &lt;<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.packageHeaderLen){</span><span style="color: rgba(0, 128, 128, 1)">33</span><span style="color: rgba(0, 0, 255, 1)">return</span> 0;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当数据长度小于数据包头部的长度时，说明它的数据是不完整的，返回0表示数据还没有完全传输到接收端</span><span style="color: rgba(0, 128, 128, 1)">34</span>         }<span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">35</span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 255, 1)">this</span>.packageHeaderLen + buffer.readInt16BE(<span style="color: rgba(0, 0, 255, 1)">this</span>.serialLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">数据包头部长度+加上数据包消息体的长度(从数据包的头部数据中获取)，就是数据包的实际长度</span><span style="color: rgba(0, 128, 128, 1)">36</span><span style="color: rgba(0, 0, 0, 1)">        }</span><span style="color: rgba(0, 128, 128, 1)">37</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">38</span><span style="color: rgba(0, 0, 0, 1)">}</span><span style="color: rgba(0, 128, 128, 1)">39</span> module.exports = MyTransformCode;</pre> </div> <p>测试自定义封包工具的编码、解码：</p> <div class="cnblogs_code"> <pre>let tf =<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MyTransformCode(); let str</span>= "他乡踏雪"<span style="color: rgba(0, 0, 0, 1)">; let buf</span>= tf.encode(str);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">编码</span> console.log(tf.decode(buf));<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解码</span> console.log(tf.getPackageLen(buf));<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取数据包字节长度</span><span style="color: rgba(0, 128, 0, 1)"> //</span><span style="color: rgba(0, 128, 0, 1)">测试结果</span> { serialNum: 0, bodyLength: 12, body: '他乡踏雪'<span style="color: rgba(0, 0, 0, 1)"> }</span>16</pre> </div> <p>3.3<strong>应用封包拆包工具MyTransform实现解决TCP的粘包问题</strong>：</p> <p>服务端示例代码：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">应用封包解决TCP粘包问题服务端</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> const net = require('net'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> const MyTransform = require('./myTransform.js'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> const server = net.createServer();<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建服务实例</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> let overageBuffer =<span style="color: rgba(0, 0, 255, 1)">null</span>;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存每一次data传输过来不完整的数据包，等待一下次data事件触发时与chunk合并处理</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> let tsf =<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MyTransform();</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> server.listen('12306', 'localhost'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> server.on('listening',()=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     console.log('服务端运行在 localhost:12306'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">11</span> server.on('connection', (socket)=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">12</span>     socket.on('data', (chunk)=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">13</span><span style="color: rgba(0, 0, 255, 1)">if</span>(overageBuffer &amp;&amp; overageBuffer.length &gt; 0<span style="color: rgba(0, 0, 0, 1)">){</span><span style="color: rgba(0, 128, 128, 1)">14</span>             chunk = Buffer.concat([overageBuffer, chunk]);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果上一次data有未不完成的数据包的数据片段，合并到这次chunk前面一起处理</span><span style="color: rgba(0, 128, 128, 1)">15</span><span style="color: rgba(0, 0, 0, 1)">        }</span><span style="color: rgba(0, 128, 128, 1)">16</span><span style="color: rgba(0, 0, 255, 1)">while</span>(tsf.getPackageLen(chunk) &amp;&amp; tsf.getPackageLen(chunk) &lt;= chunk.length){<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果接收到的数据中第一个数据包是完整的，进入循环体对数据进行拆包处理</span><span style="color: rgba(0, 128, 128, 1)">17</span>             let packageLen = tsf.getPackageLen(chunk);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">用于缓存接收到的数据中第一个包的字节长度</span><span style="color: rgba(0, 128, 128, 1)">18</span>             const packageCon = chunk.slice(0, packageLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">截取接收到的数据的第一个数据包的数据</span><span style="color: rgba(0, 128, 128, 1)">19</span>             chunk = chunk.slice(packageLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">截取除第一个数据包剩余的数据，用于下一轮循环或下一次data事件处理</span><span style="color: rgba(0, 128, 128, 1)">20</span>             const ret = tsf.decode(packageCon);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解码当前数据中第一个数据包</span><span style="color: rgba(0, 128, 128, 1)">21</span><span style="color: rgba(0, 0, 0, 1)">            console.log(ret);</span><span style="color: rgba(0, 128, 128, 1)">22</span>             socket.write(tsf.encode(ret.body, ret.serialNum));<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">讲解码的数据报再次封包发送回客户端</span><span style="color: rgba(0, 128, 128, 1)">23</span><span style="color: rgba(0, 0, 0, 1)">        };</span><span style="color: rgba(0, 128, 128, 1)">24</span>         overageBuffer = chunk;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存不完整的数据包，等待下一次data事件接收到数据后一起处理</span><span style="color: rgba(0, 128, 128, 1)">25</span><span style="color: rgba(0, 0, 0, 1)">    });</span><span style="color: rgba(0, 128, 128, 1)">26</span> });</pre> </div> <p>客户端示例代码：</p> <div class="cnblogs_code"> <pre><span style="color: rgba(0, 128, 128, 1)"> 1</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">应用封包解决TCP粘包问题客户端</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> const net = require('net'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 3</span> const MyTransform = require('./myTransform.js'<span style="color: rgba(0, 0, 0, 1)">);</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> let overageBuffer =<span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;</span><span style="color: rgba(0, 128, 128, 1)"> 5</span> let tsf =<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MyTransform();</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> const client =<span style="color: rgba(0, 0, 0, 1)"> net.createConnection({</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>     host:'localhost'<span style="color: rgba(0, 0, 0, 1)">,</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     port:12306<span style="color: rgba(0, 128, 128, 1)"> 9</span><span style="color: rgba(0, 0, 0, 1)">});</span><span style="color: rgba(0, 128, 128, 1)">10</span> client.write(tsf.encode("他乡踏雪1"<span style="color: rgba(0, 0, 0, 1)">));</span><span style="color: rgba(0, 128, 128, 1)">11</span> client.write(tsf.encode("他乡踏雪2"<span style="color: rgba(0, 0, 0, 1)">));</span><span style="color: rgba(0, 128, 128, 1)">12</span> client.write(tsf.encode("他乡踏雪3"<span style="color: rgba(0, 0, 0, 1)">));</span><span style="color: rgba(0, 128, 128, 1)">13</span> client.write(tsf.encode("他乡踏雪4"<span style="color: rgba(0, 0, 0, 1)">));</span><span style="color: rgba(0, 128, 128, 1)">14</span> client.on('data', (chunk)=&gt;<span style="color: rgba(0, 0, 0, 1)">{</span><span style="color: rgba(0, 128, 128, 1)">15</span><span style="color: rgba(0, 0, 255, 1)">if</span>(overageBuffer &amp;&amp; overageBuffer.length &gt; 0<span style="color: rgba(0, 0, 0, 1)">){</span><span style="color: rgba(0, 128, 128, 1)">16</span>         chunk = Buffer.concat([overageBuffer, chunk]);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">//如果上一次data有未不完成的数据包的数据片段，合并到这次chunk前面一起处理</span><span style="color: rgba(0, 128, 128, 1)">17</span><span style="color: rgba(0, 0, 0, 1)">    }</span><span style="color: rgba(0, 128, 128, 1)">18</span><span style="color: rgba(0, 0, 255, 1)">while</span>(tsf.getPackageLen(chunk) &amp;&amp; tsf.getPackageLen(chunk) &lt;= chunk.length){<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果接收到的数据中第一个数据包是完整的，进入循环体对数据进行拆包处理</span><span style="color: rgba(0, 128, 128, 1)">19</span>         let packageLen = tsf.getPackageLen(chunk);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">用于缓存接收到的数据中第一个包的字节长度</span><span style="color: rgba(0, 128, 128, 1)">20</span>         const packageCon = chunk.slice(0, packageLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">截取接收到的数据的第一个数据包的数据</span><span style="color: rgba(0, 128, 128, 1)">21</span>         chunk = chunk.slice(packageLen);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">截取除第一个数据包剩余的数据，用于下一轮循环或下一次data事件处理</span><span style="color: rgba(0, 128, 128, 1)">22</span>         const ret = tsf.decode(packageCon);<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">解码当前数据中第一个数据包</span><span style="color: rgba(0, 128, 128, 1)">23</span><span style="color: rgba(0, 0, 0, 1)">        console.log(ret);</span><span style="color: rgba(0, 128, 128, 1)">24</span><span style="color: rgba(0, 0, 0, 1)">    };</span><span style="color: rgba(0, 128, 128, 1)">25</span>     overageBuffer = chunk;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存不完整的数据包，等待下一次data事件接收到数据后一起处理</span><span style="color: rgba(0, 128, 128, 1)">26</span> });</pre> </div> <p>测试效果：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/e4987e6db4edcfb9e886161c362b4244.jpg" alt="nodejs的TCP相关的一些笔记"></p> <p>基于流的数据传输总是先进先出的队列传输原则，所以每一次数据的前面固定几个字节的数据都是数据中的第一个包的头部数据，所以就可以通过MyTransform工具中的getPackageLen(buffer)获取到第一个数据包的数据长度，基于这样一个原则就可以准确的判断出当前的数据中是否有完整的数据包，如果有就将这个数据包拆分出来，循环这一操作就可以将所有数据全部完整的实现数据拆分，解决TCP的Nagle算法导致到粘包和不完整数据包的问题。</p> 			                        <div class="col-md-12 mt-5">
                                                        <p>上一个：<a href="/html/category/article-1694.htm">Spring MVC启动原理详解</a></p>
                                                        <p>下一个：<a href="/html/category/article-1696.htm">spring boot security ajax_springboot集成security详解</a></p>
                                                    </div>
                                            </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-1863.htm" title="为vscode开发一款svn右键菜单扩展">为vscode开发一款svn右键菜单扩展</a></li>
                        <li class="py-2"><a href="/html/category/article-1894.htm" title="小程序自定义导航栏组件">小程序自定义导航栏组件</a></li>
                        <li class="py-2"><a href="/html/category/article-1869.htm" title="Python 一网打尽＜排序算法＞之从希尔排序算法的分治哲学开始">Python 一网打尽＜排序算法＞之从希尔排序算法的分治哲学开始</a></li>
                        <li class="py-2"><a href="/html/category/article-1898.htm" title="Kotlin 标准函数和静态方法[第一行代码 Kotlin 学习笔记]">Kotlin 标准函数和静态方法[第一行代码 Kotlin 学习笔记]</a></li>
                        <li class="py-2"><a href="/html/category/article-1878.htm" title="echart整体图形大小调整">echart整体图形大小调整</a></li>
                        <li class="py-2"><a href="/html/category/article-1876.htm" title="python入门基础字典及相关操作详解">python入门基础字典及相关操作详解</a></li>
                        <li class="py-2"><a href="/html/category/article-1910.htm" title="[转载] Python中format函数用法">[转载] Python中format函数用法</a></li>
                        <li class="py-2"><a href="/html/category/article-1938.htm" title="JavaScript数字数组的均等分割方法详解">JavaScript数字数组的均等分割方法详解</a></li>
                        <li class="py-2"><a href="/html/category/article-1904.htm" title="在Python中使用ibis,impyla,pyhive,pyspark连接Kerberos安全认证的Hive、Impala">在Python中使用ibis,impyla,pyhive,pyspark连接Kerberos安全认证的Hive、Impala</a></li>
                        <li class="py-2"><a href="/html/category/article-1882.htm" title="yum安装nginx后报错nginx: [error] open() “/run/nginx.pid“ failed">yum安装nginx后报错nginx: [error] open() “/run/nginx.pid“ failed</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">46</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">50</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>



                    </div>
                </div>
            </div> <!-- .container -->
        </div> <!-- .page-section -->
    </main>
        <footer class="page-footer">
        <div class="container">
            <div class="row">
                <div class="col-sm-6 py-2">
                    <p id="copyright">
                        Afghanistan Address 版权所有 Powered by WordPress
                    </p>
                </div>
                <div class="col-sm-6 py-2 text-right">
                    <div class="d-inline-block px-3">
                        <a href="#">Privacy</a>
                    </div>
                    <div class="d-inline-block px-3">
                        <a href="#">Contact Us</a>
                    </div>
                </div>
            </div>
        </div> <!-- .container -->
    </footer> <!-- .page-footer -->
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/jquery-3.5.1.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/bootstrap.bundle.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/wow/wow.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/owl-carousel/js/owl.carousel.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/waypoints/jquery.waypoints.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/animateNumber/jquery.animateNumber.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/google-maps.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/afghanistanaddress/theme.js"></script>
    <script>
    $(function() {
        $('.js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>